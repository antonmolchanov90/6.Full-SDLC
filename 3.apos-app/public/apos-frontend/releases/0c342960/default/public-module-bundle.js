// BUILD: src
(()=>{"use strict";var __webpack_modules__={813:()=>{eval("\n;// CONCATENATED MODULE: ./node_modules/apostrophe/modules/@apostrophecms/util/ui/src/util.js\n// Adds minimal services to the apos object replacing\n// functionality widget players can't live without,\n// and provides the `runPlayers` method to run all players\n// once if not run previously.\n//\n// Also schedules that method to run automatically when\n// the DOM is ready.\n//\n// Adds apos to window if not already present.\n//\n// This is a lean, IE11-friendly implementation.\n\n/* harmony default export */ const util = (() => {\n\n  const apos = window.apos;\n  apos.util = {};\n\n  // emit a custom event on the specified DOM element in a cross-browser way.\n  // If `data` is present, the properties of `data` will be available on the event object\n  // in your event listeners. For events unrelated to the DOM, we often emit on\n  // `document.body` and call `addEventListener` on `document.body` elsewhere.\n  //\n  // \"Where is `apos.util.on`?\" You don't need it, use `addEventListener`, which is\n  // standard.\n\n  apos.util.emit = function(el, name, data) {\n    let event;\n    try {\n      // Modern. We can't sniff for this, we can only try it. IE11\n      // has it but it's not a constructor and throws an exception\n      event = new window.CustomEvent(name);\n    } catch (e) {\n      // bc for IE11\n      event = document.createEvent('Event');\n      event.initEvent(name, true, true);\n    }\n    apos.util.assign(event, data || {});\n    el.dispatchEvent(event);\n  };\n\n  // Fetch the cookie by the given name\n  apos.util.getCookie = function(name) {\n    const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));\n    return match && match[2];\n  };\n\n  // Remove a CSS class, if present.\n  // http://youmightnotneedjquery.com/\n\n  apos.util.removeClass = function(el, className) {\n    if (el.classList) {\n      el.classList.remove(className);\n    } else {\n      el.className = el.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n    }\n  };\n\n  // Add a CSS class, if missing.\n  // http://youmightnotneedjquery.com/\n\n  apos.util.addClass = function(el, className) {\n    if (el.classList) {\n      el.classList.add(className);\n    } else {\n      el.className += ' ' + className;\n    }\n  };\n\n  // A wrapper for the native closest() method of DOM elements,\n  // where available, otherwise a polyfill for IE9+. Returns the\n  // closest ancestor of el that matches selector, where\n  // el itself is considered the closest possible ancestor.\n\n  apos.util.closest = function(el, selector) {\n    if (el.closest) {\n      return el.closest(selector);\n    }\n    // Polyfill per https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n    if (!Element.prototype.matches) {\n      Element.prototype.matches = Element.prototype.msMatchesSelector ||\n        Element.prototype.webkitMatchesSelector;\n    }\n    Element.prototype.closest = function(s) {\n      let el = this;\n      if (!document.documentElement.contains(el)) {\n        return null;\n      }\n      do {\n        if (el.matches(s)) {\n          return el;\n        }\n        el = el.parentElement || el.parentNode;\n      } while (el !== null && el.nodeType === 1);\n      return null;\n    };\n    return el.closest(selector);\n  };\n\n  // Like Object.assign. Uses Object.assign where available.\n  // (Takes us back to IE9)\n\n  apos.util.assign = function(obj1, obj2 /*,  obj3... */) {\n    if (Object.assign) {\n      return Object.assign.apply(Object, arguments);\n    }\n    let i, j, keys, key;\n    for (i = 1; (i < arguments.length); i++) {\n      keys = Object.keys(arguments[i]);\n      for (j = 0; (j < keys.length); j++) {\n        key = keys[j];\n        obj1[key] = arguments[i][key];\n      }\n    }\n    return obj1;\n  };\n\n  // Map of widget players. Adding one is as simple as:\n  // window.apos.util.widgetPlayers['widget-name'] = function(el, data, options) {}\n  //\n  // Use the widget's name, like \"apostrophe-images\", NOT the name of its module.\n  //\n  // Your player receives the DOM element of the widget and the\n  // pre-parsed `data` and `options` objects associated with it,\n  // as objects. el is NOT a jQuery object, because jQuery is not pushed\n  // (we push no libraries in the lean world).\n  //\n  // Your player should add any needed javascript effects to\n  // THAT ONE WIDGET and NO OTHER. Don't worry about finding the\n  // others, we will do that for you and we guarantee only one call per widget.\n\n  apos.util.widgetPlayers = {};\n\n  // Run the given function whenever the DOM has new changes that\n  // may require attention. The passed function will be\n  // called when the DOM is ready on initial page load, and also\n  // when the main content area has been refreshed by the editor.\n  // Note that you don't need this for widgets; see widget players.\n\n  // NOTE: onReadyAndRefresh has been aliased to apos.util.onReady,\n  // which is the recommended way to call this functionality.\n  // onReadyAndRefresh will be deprecated in the next major version.\n\n  apos.util.onReadyAndRefresh = function(fn) {\n    onReady(fn);\n    // Allow Apostrophe to create the bus first\n    setTimeout(function() {\n      apos.bus && apos.bus.$on('refreshed', fn);\n    }, 0);\n    function onReady(fn) {\n      if (document.readyState !== 'loading') {\n        setTimeout(fn, 0);\n      } else if (document.addEventListener) {\n        document.addEventListener('DOMContentLoaded', fn);\n      } else {\n        document.attachEvent('onreadystatechange', function() {\n          if (document.readyState !== 'loading') {\n            fn();\n          }\n        });\n      }\n    }\n  };\n\n  // Alias for onReadyAndRefresh, the recommended way to use and document this functionality\n  apos.util.onReady = apos.util.onReadyAndRefresh.bind(apos.util.onReadyAndRefresh);\n\n  // Run all the players that haven't been run. Invoked for you at DOMready\n  // time. You may also invoke it if you just AJAXed in some content and\n  // have reason to suspect there could be widgets in there. You may pass:\n  //\n  // * Nothing at all - entire document is searched for new widgets to enhance, or\n  // * A DOM element - new widgets to enhance are found within this scope only.\n  //\n  // To register a widget player for the `apostrophe-images` widget, write:\n  //\n  // `apos.util.widgetPlayers['apostrophe-images'] = function(el, data, options) { ... }`\n  //\n  // `el` is a DOM element, not a jQuery object. Otherwise identical to\n  // traditional Apostrophe widget players. `data` contains the properties\n  // of the widget itself, `options` contains the options that were\n  // passed to it at the area level.\n  //\n  // Your player is guaranteed to run only once per widget. Hint:\n  // DON'T try to find all the widgets. DO just enhance `el`.\n  // This is a computer science principle known as \"separation of concerns.\"\n\n  apos.util.runPlayers = function(el) {\n    const players = apos.util.widgetPlayers;\n    const playerList = Object.keys(players);\n\n    for (let i = 0; i < playerList.length; i++) {\n      const playerOpts = players[playerList[i]];\n      const playerEls = (el || document).querySelectorAll(playerOpts.selector);\n\n      playerEls.forEach(function (el) {\n        if (el.aposWidgetPlayed) {\n          return;\n        }\n        // Use an actual property, not a DOM attribute or\n        // \"data\" prefix property, to avoid the problem of\n        // elements cloned from innerHTML appearing to have\n        // been played too\n        el.aposWidgetPlayed = true;\n        playerOpts.player(el);\n      });\n    }\n  };\n\n  // Schedule runPlayers to run as soon as the document is ready, and also\n  // when the page is partially refreshed by the editor.\n\n  if (!apos.bus) {\n    apos.util.onReadyAndRefresh(function() {\n      apos.util.runPlayers();\n    });\n  }\n\n  // Given an attachment field value,\n  // return the file URL. If options.size is set, return the URL for\n  // that size (one-sixth, one-third, one-half, two-thirds, full, max).\n  // full is \"full width\" (1140px), not the original.\n  //\n  // If you don't pass the options object, or options does not\n  // have a size property, you'll get the URL of the original.\n  // IMPORTANT: FOR IMAGES, THIS MAY BE A VERY LARGE FILE, NOT\n  // WHAT YOU WANT. Set `size` appropriately!\n  //\n  // You can also pass a crop object (the crop must already exist).\n\n  apos.util.attachmentUrl = function(file, options) {\n    let path = apos.uploadsUrl + '/attachments/' + file._id + '-' + file.name;\n    if (!options) {\n      options = {};\n    }\n    // NOTE: the crop must actually exist already, you can't just invent them\n    // browser-side without the crop API ever having come into play. If the\n    // width is 0 the user hit save in the cropper without cropping, use\n    // the regular version\n    let crop;\n    if (options.crop && options.crop.width) {\n      crop = options.crop;\n    } else if (file.crop && file.crop.width) {\n      crop = file.crop;\n    }\n    if (crop) {\n      path += '.' + crop.left + '.' + crop.top + '.' + crop.width + '.' + crop.height;\n    }\n    let effectiveSize;\n    if ((!options.size) || (options.size === 'original')) {\n      effectiveSize = false;\n    } else {\n      effectiveSize = options.size;\n    }\n    if (effectiveSize) {\n      path += '.' + effectiveSize;\n    }\n    return path + '.' + file.extension;\n  };\n\n  // Returns true if the uri references the same site (same host and port) as the\n  // current page. Cross-browser implementation, valid at least back to IE11.\n  // Regarding port numbers, this will match as long as the URIs are consistent\n  // about not explicitly specifying the port number when it is 80 (HTTP) or 443 (HTTPS),\n  // which is generally the case.\n\n  apos.util.sameSite = function(uri) {\n    const matches = uri.match(/^(https?:)?\\/\\/([^/]+)/);\n    if (!matches) {\n      // If URI is not absolute or protocol-relative then it is always same-origin\n      return true;\n    }\n    return window.location.host === matches[2];\n  };\n});\n\n;// CONCATENATED MODULE: ./node_modules/apostrophe/modules/@apostrophecms/util/ui/src/http.js\n/* harmony default export */ const http = (() => {\n  // Adds the apos.http client, which has the same API\n  // as the server-side apos.http client, although it may\n  // not have exactly the same features available.\n  // This is a lean, IE11-friendly implementation.\n\n  const busyActive = {};\n  const apos = window.apos;\n  apos.http = {};\n\n  // Send a POST request. Note that POST body data should be in\n  // `options.body`. See `apos.http.remote` for details.\n  // You do NOT have to pass a callback unless you must support IE11\n  // and do not want to include a promise polyfill in your build.\n\n  apos.http.post = function(url, options, callback) {\n    return apos.http.remote('POST', url, options, callback);\n  };\n\n  // Send a GET request. Note that query string data may be in\n  // `options.qs`. See `apos.http.remote` for details.\n  // You do NOT have to pass a callback unless you must support IE11\n  // and do not want to include a promise polyfill in your build.\n  apos.http.get = function(url, options, callback) {\n    return apos.http.remote('GET', url, options, callback);\n  };\n\n  // Send a PATCH request. Note that PATCH body data should be in\n  // `options.body`. See `apos.http.remote` for details.\n  // You do NOT have to pass a callback unless you must support IE11\n  // and do not want to include a promise polyfill in your build.\n  apos.http.patch = function(url, options, callback) {\n    return apos.http.remote('PATCH', url, options, callback);\n  };\n\n  // Send a PUT request. Note that PUT body data should be in\n  // `options.body`. See `apos.http.remote` for details.\n  // You do NOT have to pass a callback unless you must support IE11\n  // and do not want to include a promise polyfill in your build.\n  apos.http.put = function(url, options, callback) {\n    return apos.http.remote('PUT', url, options, callback);\n  };\n\n  // Send a DELETE request. See `apos.http.remote` for details.\n  // You do NOT have to pass a callback unless you must support IE11\n  // and do not want to include a promise polyfill in your build.\n  apos.http.delete = function(url, options, callback) {\n    return apos.http.remote('DELETE', url, options, callback);\n  };\n\n  // Send an HTTP request with the given method to the given URL and return the response body.\n  //\n  // The callback is optional as long as Promise support is present in the browser, directly or as\n  // a polyfill. If a callback is used it will receive `(err, result)` where `result` is the\n  // return value described below.\n  //\n  // Accepts the following options:\n  //\n  // `qs` (pass object; builds a query string, does not support recursion)\n  // `send`: by default, `options.body` is sent as JSON if it is an object and it is not a\n  // `FormData` object. If `send` is set to `json`, it is always sent as JSON.\n  // `body` (request body, not for GET; if an object or array, sent as JSON, otherwise sent as-is, unless\n  // the `send` option is set)\n  // `parse` (can be 'json` to always parse the response body as JSON, otherwise the response body is\n  // parsed as JSON only if the content-type is application/json)\n  // `headers` (an object containing header names and values)\n  // `draft` (if true, always add aposMode=draft to the query string, creating one if needed)\n  // `csrf` (unless explicitly set to `false`, send the X-XSRF-TOKEN header when talking to the same site)\n  // `fullResponse` (if true, return an object with `status`, `headers` and `body`\n  // properties, rather than returning the body directly; the individual `headers` are canonicalized\n  // to lowercase names. If there are duplicate headers after canonicalization only the\n  // last value is returned. If a header appears multiple times an array is returned for it)\n  // `downloadProgress` (may be a function accepting `received` and `total` parameters. May never be called. If\n  // called, `received` will be the bytes sent so far, and `total` will be the total bytes to be\n  // received. If the total is unknown, it will be `null`)\n  // `uploadProgress` (may be a function accepting `sent` and `total` parameters. May never be called. If\n  // called, `sent` will be the bytes sent so far, and `total` will be the total bytes to be\n  // sent. If the total is unknown, it will be `null`)\n  //\n  // If the status code is >= 400 an error is thrown. The error object will be\n  // similar to a `fullResponse` object, with a `status` property.\n  //\n  // If the URL is site-relative (starts with /) it will be requested from\n  // the apostrophe site itself.\n\n  // Just before the XMLHTTPRequest is sent this method emits an\n  // `apos-before-post` event on `document.body` (where `post` changes\n  // to match the method, in lower case). The event object\n  // has `uri`, `data` and `request` properties. `request` is the\n  // XMLHTTPRequest object. You can use this to set custom headers\n  // on all lean requests, etc.\n\n  apos.http.remote = function(method, url, options, callback) {\n    if (!callback) {\n      if (!window.Promise) {\n        throw new Error('If you wish to receive a promise from apos.http methods in older browsers you must have a Promise polyfill. If you do not want to provide one, pass a callback instead.');\n      }\n      return new window.Promise(function(resolve, reject) {\n        return apos.http.remote(method, url, options, function(err, result) {\n          if (err) {\n            return reject(err);\n          }\n          return resolve(result);\n        });\n      });\n    }\n\n    if (apos.prefix) {\n      // We don't need a prefix if the target URL is already prefixed,\n      // which any absolute URL should be\n      if (url.substring(0, 1) === '/') {\n        url = apos.prefix + url;\n      }\n    }\n\n    let query;\n    let qat;\n\n    // Intentional true / falsey check for determining\n    // what set of docs the request is interested in\n    if (options.draft != null) {\n      if (options.qs) {\n        // Already assumes no query parameters baked into URL, so OK to\n        // just extend qs\n        options.qs = options.draft\n          ? apos.util.assign({ aposMode: 'draft' }, options.qs)\n          : apos.util.assign({ aposMode: 'published' }, options.qs);\n      } else {\n        // Careful, there could be existing query parameters baked into url\n        qat = url.indexOf('?');\n        if (qat !== -1) {\n          query = apos.http.parseQuery(url.substring(qat));\n        } else {\n          query = {};\n        }\n        query.aposMode = options.draft ? 'draft' : 'published';\n        url = apos.http.addQueryToUrl(url, query);\n      }\n    }\n\n    const busyName = options.busy === true ? 'busy' : options.busy;\n    const xmlhttp = new XMLHttpRequest();\n    const csrfToken = apos.csrfCookieName ? apos.util.getCookie(apos.csrfCookieName) : 'csrf-fallback';\n    let data = options.body;\n    let keys;\n    let i;\n    if (options.qs) {\n      url = apos.http.addQueryToUrl(url, options.qs);\n    }\n    if (options.busy) {\n      if (!busyActive[busyName]) {\n        busyActive[busyName] = 0;\n        apos.bus.$emit('busy', {\n          active: true,\n          name: busyName\n        });\n      }\n      // keep track of nested calls\n      busyActive[busyName]++;\n    }\n    xmlhttp.open(method, url);\n    const formData = window.FormData && (data instanceof window.FormData);\n    const sendJson = (options.send === 'json') || (options.body && ((typeof options.body) === 'object') && !formData);\n    if (sendJson) {\n      xmlhttp.setRequestHeader('Content-Type', 'application/json');\n    }\n    if (csrfToken && (options.csrf !== false)) {\n      if (apos.util.sameSite(url)) {\n        xmlhttp.setRequestHeader('X-XSRF-TOKEN', csrfToken);\n      }\n    }\n    if (options.headers) {\n      keys = Object.keys(options.headers);\n      for (i = 0; (i < keys.length); i++) {\n        xmlhttp.setRequestHeader(keys[i], options.headers[keys[i]]);\n      }\n    }\n    apos.util.emit(document.body, 'apos-before-' + method.toLowerCase(), {\n      uri: url,\n      data: options.body,\n      request: xmlhttp\n    });\n    if (sendJson) {\n      data = JSON.stringify(options.body);\n    } else {\n      data = options.body;\n    }\n    xmlhttp.addEventListener('load', function() {\n      let data = null;\n      const responseHeader = this.getResponseHeader('Content-Type');\n      if (responseHeader || (options.parse === 'json')) {\n        if ((options.parse === 'json') || (responseHeader.match(/^application\\/json/))) {\n          try {\n            data = JSON.parse(this.responseText);\n          } catch (e) {\n            return callback(e);\n          }\n        } else {\n          data = this.responseText;\n        }\n      }\n\n      if (xmlhttp.status < 400) {\n        if (options.fullResponse) {\n          return callback(null, {\n            body: data,\n            status: xmlhttp.status,\n            headers: getHeaders()\n          });\n        } else {\n          return callback(null, data);\n        }\n      } else {\n        const error = new Error((data && data.message) || (data && data.name) || 'Error');\n        error.status = xmlhttp.status;\n        error.name = (data && data.name);\n        error.body = data;\n        error.headers = getHeaders();\n        return callback(error);\n      }\n    });\n    xmlhttp.addEventListener('abort', function(evt) {\n      return callback(evt);\n    });\n    xmlhttp.addEventListener('error', function(evt) {\n      return callback(evt);\n    });\n    if (options.downloadProgress) {\n      xmlhttp.addEventListener('progress', function(evt) {\n        options.downloadProgress(evt.loaded, evt.lengthComputable ? evt.total : null);\n      });\n    }\n    if (xmlhttp.upload && options.uploadProgress) {\n      xmlhttp.upload.addEventListener('progress', function(evt) {\n        options.uploadProgress(evt.loaded, evt.lengthComputable ? evt.total : null);\n      });\n    }\n    xmlhttp.addEventListener('loadend', function (evt) {\n      if (options.busy) {\n        busyActive[busyName]--;\n        if (!busyActive[busyName]) {\n          // if no nested calls, disable the \"busy\" state\n          apos.bus.$emit('busy', {\n            active: false,\n            name: busyName\n          });\n        }\n      }\n    });\n    xmlhttp.send(data);\n\n    function getHeaders() {\n      const headers = xmlhttp.getAllResponseHeaders();\n      if (!headers) {\n        return {};\n      }\n      // Per MDN\n      const arr = headers.trim().split(/[\\r\\n]+/);\n      // Create a map of header names to values\n      const headerMap = {};\n      arr.forEach(function (line) {\n        const parts = line.split(': ');\n        const header = parts.shift();\n        if (!header) {\n          return;\n        }\n        const value = parts.shift();\n        // Optional support for fetching arrays of headers with the same name\n        // could be added at a later time if anyone really cares. Usually\n        // just a source of bugs\n        headerMap[header.toLowerCase()] = value;\n      });\n      return headerMap;\n    }\n  };\n\n  // Parse a query string. You can pass with or without the\n  // leading ?. Don't pass the entire URL. Supports objects,\n  // arrays and nesting with the classic PHP/Java bracket syntax.\n  // If a key is set with no = it is considered null, per\n  // the java convention. Good for use with window.location.search.\n\n  apos.http.parseQuery = function(query) {\n    query = query.replace(/^\\?/, '');\n    const data = {};\n    const pairs = query.split('&');\n    pairs.forEach(function(pair) {\n      let parts;\n      if (pair.indexOf('=') === -1) {\n        patch(pair, null);\n      } else {\n        parts = pair.split('=');\n        if (parts) {\n          patch(parts[0], parts[1]);\n        }\n      }\n    });\n    return data.root || {};\n    function patch(key, value) {\n      let match;\n      let parentKey = 'root';\n      let context = data;\n      key = decodeURIComponent(key);\n      const path = key.split('[');\n      path.forEach(function(subKey) {\n        if (subKey === ']') {\n          if (!Array.isArray(context[parentKey])) {\n            context[parentKey] = [];\n          }\n          context = context[parentKey];\n          parentKey = context.length;\n        } else if (subKey.match(/^\\d+]/)) {\n          match = subKey.match(/^\\d+/);\n          if (!Array.isArray(context[parentKey])) {\n            context[parentKey] = [];\n          }\n          context = context[parentKey];\n          parentKey = parseInt(match);\n        } else {\n          match = subKey.replace(']', '');\n          if (!context[parentKey]) {\n            context[parentKey] = {};\n          }\n          context = context[parentKey];\n          parentKey = match;\n        }\n      });\n      value = (value === null) ? value : decodeURIComponent(value);\n      if (Array.isArray(context[parentKey])) {\n        context[parentKey].push(value);\n      } else if (context[parentKey] !== undefined) {\n        context[parentKey] = [ context[parentKey], value ];\n      } else {\n        context[parentKey] = value;\n      }\n    }\n  };\n\n  // Adds query string data to url. Supports nested structures with objects\n  // and arrays, in a way compatible with qs and most other parsers including\n  // those baked into PHP frameworks etc. If the URL already contains a query\n  // it is discarded and replaced with the new one. All non-query parts of the\n  // URL remain unchanged.\n\n  apos.http.addQueryToUrl = function(url, data) {\n    let hash = '';\n    const hashAt = url.indexOf('#');\n    if (hashAt !== -1) {\n      hash = url.substring(hashAt);\n      url = url.substring(0, hashAt);\n    }\n    url = url.replace(/\\?.*$/, '');\n    let i;\n    let flat;\n    if ((data != null) && ((typeof data) === 'object')) {\n      flat = flatten('', data);\n      for (i = 0; (i < flat.length); i++) {\n        const key = flat[i][0];\n        const val = flat[i][1];\n        if (i > 0) {\n          url += '&';\n        } else {\n          url += '?';\n        }\n        if (val == null) {\n          // Java-style distinction between null and empty string\n          url += encodeURIComponent(key);\n        } else {\n          url += encodeURIComponent(key) + '=' + encodeURIComponent(val);\n        }\n      }\n    }\n    return url + hash;\n    function flatten(path, data) {\n      let flat = [];\n      let keys;\n      let i;\n      if (Array.isArray(data)) {\n        for (i = 0; (i < data.length); i++) {\n          insert(i, data[i]);\n        }\n      } else {\n        keys = Object.keys(data);\n        for (i = 0; (i < keys.length); i++) {\n          insert(keys[i], data[keys[i]]);\n        }\n      }\n      return flat;\n      function insert(key, datum) {\n        if ((datum != null) && ((typeof datum) === 'object')) {\n          flat = flat.concat(flatten(path.length ? path + '[' + key + ']' : key, datum));\n        } else {\n          flat.push([ path.length ? path + '[' + key + ']' : key, datum ]);\n        }\n      }\n    }\n  };\n});\n\n;// CONCATENATED MODULE: ./node_modules/apostrophe/modules/@apostrophecms/util/ui/src/index.js\n\n\n\n/* harmony default export */ const src = (() => {\n  util();\n  http();\n});\n\n;// CONCATENATED MODULE: ./node_modules/apostrophe/modules/@apostrophecms/video-widget/ui/src/index.js\n/* harmony default export */ const ui_src = (() => {\n  apos.util.widgetPlayers['@apostrophecms/video'] = {\n    selector: '[data-apos-video-widget]',\n    player: function(el) {\n      const videoUrl = el.getAttribute('data-apos-video-url');\n      let queryResult;\n\n      if (!videoUrl) {\n        return;\n      }\n\n      queryAndPlay(el, {\n        url: videoUrl\n      });\n\n      function queryAndPlay(el, options) {\n        apos.util.removeClass(el, 'apos-oembed-invalid');\n        apos.util.addClass(el, 'apos-oembed-busy');\n        if (!options.url) {\n          return fail('undefined');\n        }\n        return query(options, function(err, result) {\n          queryResult = result;\n          if (err || (options.type && (result.type !== options.type))) {\n            return fail(err || 'inappropriate');\n          }\n          apos.util.removeClass(el, 'apos-oembed-busy');\n          return play(el, result);\n        });\n      }\n\n      function query(options, callback) {\n        const opts = {\n          qs: {\n            url: options.url\n          }\n        };\n        return apos.http.get('/api/v1/@apostrophecms/oembed/query', opts, callback);\n      }\n\n      function play(el, result) {\n        const shaker = document.createElement('div');\n        shaker.innerHTML = result.html;\n        const inner = shaker.firstChild;\n        inner.setAttribute('data-apos-video-canvas', '');\n        el.innerHTML = '';\n        if (!inner) {\n          return;\n        }\n        inner.removeAttribute('width');\n        inner.removeAttribute('height');\n        el.append(inner);\n        // wait for CSS width to be known\n        setTimeout(function() {\n          // If oembed results include width and height we can get the\n          // video aspect ratio right\n          if (result.width && result.height) {\n            inner.style.width = '100%';\n            resizeVideo(inner);\n            // If we need to initially size the video, also resize it on window\n            // resize.\n            window.addEventListener('resize', resizeHandler);\n          } else {\n            // No, so assume the oembed HTML code is responsive.\n          }\n        }, 0);\n      }\n\n      function resizeVideo(canvasEl) {\n        canvasEl.style.height = ((queryResult.height / queryResult.width) * canvasEl.offsetWidth) + 'px';\n      };\n\n      function resizeHandler() {\n        if (document.contains(el)) {\n          resizeVideo(el.querySelector('[data-apos-video-canvas]'));\n        } else {\n          window.removeEventListener('resize', resizeHandler);\n        }\n      }\n\n      function fail(err) {\n        apos.util.removeClass(el, 'apos-oembed-busy');\n        apos.util.addClass(el, 'apos-oembed-invalid');\n        console.error(err);\n        if (err !== 'undefined') {\n          el.innerHTML = '<p>Error loading video</p>';\n        } else {\n          el.innerHTML = '';\n        }\n      }\n    }\n  };\n});\n\n;// CONCATENATED MODULE: ./modules/asset/ui/src/index.js\n/* harmony default export */ const asset_ui_src = (() => {\n  // Your own project level JS may go here\n  console.log('Hello World');\n});\n\n;// CONCATENATED MODULE: ./modules/asset/ui/src/index.scss\n// extracted by mini-css-extract-plugin\n\n;// CONCATENATED MODULE: ./apos-build/default/src-import.js\n(function() {\n    window.apos = window.apos || {};\n    var data = document.body && document.body.getAttribute('data-apos');\n    Object.assign(window.apos, JSON.parse(data || '{}'));\n    if (data) {\n      document.body.removeAttribute('data-apos');\n    }\n    if (window.apos.modules) {\n      for (const module of Object.values(window.apos.modules)) {\n        if (module.alias) {\n          window.apos[module.alias] = module;\n        }\n      }\n    }\n})();\n\n\n\n\n\n\n\n\n  \nsrc();\nui_src();\nasset_ui_src();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hMy1ib2lsZXJwbGF0ZS8uL25vZGVfbW9kdWxlcy9hcG9zdHJvcGhlL21vZHVsZXMvQGFwb3N0cm9waGVjbXMvdXRpbC91aS9zcmMvdXRpbC5qcz85YjhkIiwid2VicGFjazovL2EzLWJvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL2Fwb3N0cm9waGUvbW9kdWxlcy9AYXBvc3Ryb3BoZWNtcy91dGlsL3VpL3NyYy9odHRwLmpzPzJiNTQiLCJ3ZWJwYWNrOi8vYTMtYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvYXBvc3Ryb3BoZS9tb2R1bGVzL0BhcG9zdHJvcGhlY21zL3V0aWwvdWkvc3JjL2luZGV4LmpzPzk5OTQiLCJ3ZWJwYWNrOi8vYTMtYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvYXBvc3Ryb3BoZS9tb2R1bGVzL0BhcG9zdHJvcGhlY21zL3ZpZGVvLXdpZGdldC91aS9zcmMvaW5kZXguanM/MmM1NSIsIndlYnBhY2s6Ly9hMy1ib2lsZXJwbGF0ZS8uL21vZHVsZXMvYXNzZXQvdWkvc3JjL2luZGV4LmpzPzM3N2QiLCJ3ZWJwYWNrOi8vYTMtYm9pbGVycGxhdGUvLi9tb2R1bGVzL2Fzc2V0L3VpL3NyYy9pbmRleC5zY3NzPzFiMGYiLCJ3ZWJwYWNrOi8vYTMtYm9pbGVycGxhdGUvLi9hcG9zLWJ1aWxkL2RlZmF1bHQvc3JjLWltcG9ydC5qcz80YzQzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTs7QUFFQTtB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7QUM1RkYsbURBQWU7QUFDZjtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7QUNIRjs7O0FDQUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFpTDs7O0FBR0c7OztBQUc5Qzs7OztBQUlTLEdBQVU7QUFDMUosTUFBVTtBQUNWLFlBQVUiLCJmaWxlIjoiODEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQWRkcyBtaW5pbWFsIHNlcnZpY2VzIHRvIHRoZSBhcG9zIG9iamVjdCByZXBsYWNpbmdcbi8vIGZ1bmN0aW9uYWxpdHkgd2lkZ2V0IHBsYXllcnMgY2FuJ3QgbGl2ZSB3aXRob3V0LFxuLy8gYW5kIHByb3ZpZGVzIHRoZSBgcnVuUGxheWVyc2AgbWV0aG9kIHRvIHJ1biBhbGwgcGxheWVyc1xuLy8gb25jZSBpZiBub3QgcnVuIHByZXZpb3VzbHkuXG4vL1xuLy8gQWxzbyBzY2hlZHVsZXMgdGhhdCBtZXRob2QgdG8gcnVuIGF1dG9tYXRpY2FsbHkgd2hlblxuLy8gdGhlIERPTSBpcyByZWFkeS5cbi8vXG4vLyBBZGRzIGFwb3MgdG8gd2luZG93IGlmIG5vdCBhbHJlYWR5IHByZXNlbnQuXG4vL1xuLy8gVGhpcyBpcyBhIGxlYW4sIElFMTEtZnJpZW5kbHkgaW1wbGVtZW50YXRpb24uXG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+IHtcblxuICBjb25zdCBhcG9zID0gd2luZG93LmFwb3M7XG4gIGFwb3MudXRpbCA9IHt9O1xuXG4gIC8vIGVtaXQgYSBjdXN0b20gZXZlbnQgb24gdGhlIHNwZWNpZmllZCBET00gZWxlbWVudCBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LlxuICAvLyBJZiBgZGF0YWAgaXMgcHJlc2VudCwgdGhlIHByb3BlcnRpZXMgb2YgYGRhdGFgIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3RcbiAgLy8gaW4geW91ciBldmVudCBsaXN0ZW5lcnMuIEZvciBldmVudHMgdW5yZWxhdGVkIHRvIHRoZSBET00sIHdlIG9mdGVuIGVtaXQgb25cbiAgLy8gYGRvY3VtZW50LmJvZHlgIGFuZCBjYWxsIGBhZGRFdmVudExpc3RlbmVyYCBvbiBgZG9jdW1lbnQuYm9keWAgZWxzZXdoZXJlLlxuICAvL1xuICAvLyBcIldoZXJlIGlzIGBhcG9zLnV0aWwub25gP1wiIFlvdSBkb24ndCBuZWVkIGl0LCB1c2UgYGFkZEV2ZW50TGlzdGVuZXJgLCB3aGljaCBpc1xuICAvLyBzdGFuZGFyZC5cblxuICBhcG9zLnV0aWwuZW1pdCA9IGZ1bmN0aW9uKGVsLCBuYW1lLCBkYXRhKSB7XG4gICAgbGV0IGV2ZW50O1xuICAgIHRyeSB7XG4gICAgICAvLyBNb2Rlcm4uIFdlIGNhbid0IHNuaWZmIGZvciB0aGlzLCB3ZSBjYW4gb25seSB0cnkgaXQuIElFMTFcbiAgICAgIC8vIGhhcyBpdCBidXQgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBhbmQgdGhyb3dzIGFuIGV4Y2VwdGlvblxuICAgICAgZXZlbnQgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KG5hbWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGJjIGZvciBJRTExXG4gICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXZlbnQuaW5pdEV2ZW50KG5hbWUsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgICBhcG9zLnV0aWwuYXNzaWduKGV2ZW50LCBkYXRhIHx8IHt9KTtcbiAgICBlbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfTtcblxuICAvLyBGZXRjaCB0aGUgY29va2llIGJ5IHRoZSBnaXZlbiBuYW1lXG4gIGFwb3MudXRpbC5nZXRDb29raWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58ICknICsgbmFtZSArICc9KFteO10rKScpKTtcbiAgICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMl07XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGEgQ1NTIGNsYXNzLCBpZiBwcmVzZW50LlxuICAvLyBodHRwOi8veW91bWlnaHRub3RuZWVkanF1ZXJ5LmNvbS9cblxuICBhcG9zLnV0aWwucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbihlbCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShuZXcgUmVnRXhwKCcoXnxcXFxcYiknICsgY2xhc3NOYW1lLnNwbGl0KCcgJykuam9pbignfCcpICsgJyhcXFxcYnwkKScsICdnaScpLCAnICcpO1xuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYSBDU1MgY2xhc3MsIGlmIG1pc3NpbmcuXG4gIC8vIGh0dHA6Ly95b3VtaWdodG5vdG5lZWRqcXVlcnkuY29tL1xuXG4gIGFwb3MudXRpbC5hZGRDbGFzcyA9IGZ1bmN0aW9uKGVsLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTmFtZSArPSAnICcgKyBjbGFzc05hbWU7XG4gICAgfVxuICB9O1xuXG4gIC8vIEEgd3JhcHBlciBmb3IgdGhlIG5hdGl2ZSBjbG9zZXN0KCkgbWV0aG9kIG9mIERPTSBlbGVtZW50cyxcbiAgLy8gd2hlcmUgYXZhaWxhYmxlLCBvdGhlcndpc2UgYSBwb2x5ZmlsbCBmb3IgSUU5Ky4gUmV0dXJucyB0aGVcbiAgLy8gY2xvc2VzdCBhbmNlc3RvciBvZiBlbCB0aGF0IG1hdGNoZXMgc2VsZWN0b3IsIHdoZXJlXG4gIC8vIGVsIGl0c2VsZiBpcyBjb25zaWRlcmVkIHRoZSBjbG9zZXN0IHBvc3NpYmxlIGFuY2VzdG9yLlxuXG4gIGFwb3MudXRpbC5jbG9zZXN0ID0gZnVuY3Rpb24oZWwsIHNlbGVjdG9yKSB7XG4gICAgaWYgKGVsLmNsb3Nlc3QpIHtcbiAgICAgIHJldHVybiBlbC5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICB9XG4gICAgLy8gUG9seWZpbGwgcGVyIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3RcbiAgICBpZiAoIUVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMpIHtcbiAgICAgIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG4gICAgfVxuICAgIEVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QgPSBmdW5jdGlvbihzKSB7XG4gICAgICBsZXQgZWwgPSB0aGlzO1xuICAgICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWwpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZG8ge1xuICAgICAgICBpZiAoZWwubWF0Y2hlcyhzKSkge1xuICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQgfHwgZWwucGFyZW50Tm9kZTtcbiAgICAgIH0gd2hpbGUgKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICB9O1xuXG4gIC8vIExpa2UgT2JqZWN0LmFzc2lnbi4gVXNlcyBPYmplY3QuYXNzaWduIHdoZXJlIGF2YWlsYWJsZS5cbiAgLy8gKFRha2VzIHVzIGJhY2sgdG8gSUU5KVxuXG4gIGFwb3MudXRpbC5hc3NpZ24gPSBmdW5jdGlvbihvYmoxLCBvYmoyIC8qLCAgb2JqMy4uLiAqLykge1xuICAgIGlmIChPYmplY3QuYXNzaWduKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGxldCBpLCBqLCBrZXlzLCBrZXk7XG4gICAgZm9yIChpID0gMTsgKGkgPCBhcmd1bWVudHMubGVuZ3RoKTsgaSsrKSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzW2ldKTtcbiAgICAgIGZvciAoaiA9IDA7IChqIDwga2V5cy5sZW5ndGgpOyBqKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgb2JqMVtrZXldID0gYXJndW1lbnRzW2ldW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmoxO1xuICB9O1xuXG4gIC8vIE1hcCBvZiB3aWRnZXQgcGxheWVycy4gQWRkaW5nIG9uZSBpcyBhcyBzaW1wbGUgYXM6XG4gIC8vIHdpbmRvdy5hcG9zLnV0aWwud2lkZ2V0UGxheWVyc1snd2lkZ2V0LW5hbWUnXSA9IGZ1bmN0aW9uKGVsLCBkYXRhLCBvcHRpb25zKSB7fVxuICAvL1xuICAvLyBVc2UgdGhlIHdpZGdldCdzIG5hbWUsIGxpa2UgXCJhcG9zdHJvcGhlLWltYWdlc1wiLCBOT1QgdGhlIG5hbWUgb2YgaXRzIG1vZHVsZS5cbiAgLy9cbiAgLy8gWW91ciBwbGF5ZXIgcmVjZWl2ZXMgdGhlIERPTSBlbGVtZW50IG9mIHRoZSB3aWRnZXQgYW5kIHRoZVxuICAvLyBwcmUtcGFyc2VkIGBkYXRhYCBhbmQgYG9wdGlvbnNgIG9iamVjdHMgYXNzb2NpYXRlZCB3aXRoIGl0LFxuICAvLyBhcyBvYmplY3RzLiBlbCBpcyBOT1QgYSBqUXVlcnkgb2JqZWN0LCBiZWNhdXNlIGpRdWVyeSBpcyBub3QgcHVzaGVkXG4gIC8vICh3ZSBwdXNoIG5vIGxpYnJhcmllcyBpbiB0aGUgbGVhbiB3b3JsZCkuXG4gIC8vXG4gIC8vIFlvdXIgcGxheWVyIHNob3VsZCBhZGQgYW55IG5lZWRlZCBqYXZhc2NyaXB0IGVmZmVjdHMgdG9cbiAgLy8gVEhBVCBPTkUgV0lER0VUIGFuZCBOTyBPVEhFUi4gRG9uJ3Qgd29ycnkgYWJvdXQgZmluZGluZyB0aGVcbiAgLy8gb3RoZXJzLCB3ZSB3aWxsIGRvIHRoYXQgZm9yIHlvdSBhbmQgd2UgZ3VhcmFudGVlIG9ubHkgb25lIGNhbGwgcGVyIHdpZGdldC5cblxuICBhcG9zLnV0aWwud2lkZ2V0UGxheWVycyA9IHt9O1xuXG4gIC8vIFJ1biB0aGUgZ2l2ZW4gZnVuY3Rpb24gd2hlbmV2ZXIgdGhlIERPTSBoYXMgbmV3IGNoYW5nZXMgdGhhdFxuICAvLyBtYXkgcmVxdWlyZSBhdHRlbnRpb24uIFRoZSBwYXNzZWQgZnVuY3Rpb24gd2lsbCBiZVxuICAvLyBjYWxsZWQgd2hlbiB0aGUgRE9NIGlzIHJlYWR5IG9uIGluaXRpYWwgcGFnZSBsb2FkLCBhbmQgYWxzb1xuICAvLyB3aGVuIHRoZSBtYWluIGNvbnRlbnQgYXJlYSBoYXMgYmVlbiByZWZyZXNoZWQgYnkgdGhlIGVkaXRvci5cbiAgLy8gTm90ZSB0aGF0IHlvdSBkb24ndCBuZWVkIHRoaXMgZm9yIHdpZGdldHM7IHNlZSB3aWRnZXQgcGxheWVycy5cblxuICAvLyBOT1RFOiBvblJlYWR5QW5kUmVmcmVzaCBoYXMgYmVlbiBhbGlhc2VkIHRvIGFwb3MudXRpbC5vblJlYWR5LFxuICAvLyB3aGljaCBpcyB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIGNhbGwgdGhpcyBmdW5jdGlvbmFsaXR5LlxuICAvLyBvblJlYWR5QW5kUmVmcmVzaCB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cblxuICBhcG9zLnV0aWwub25SZWFkeUFuZFJlZnJlc2ggPSBmdW5jdGlvbihmbikge1xuICAgIG9uUmVhZHkoZm4pO1xuICAgIC8vIEFsbG93IEFwb3N0cm9waGUgdG8gY3JlYXRlIHRoZSBidXMgZmlyc3RcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgYXBvcy5idXMgJiYgYXBvcy5idXMuJG9uKCdyZWZyZXNoZWQnLCBmbik7XG4gICAgfSwgMCk7XG4gICAgZnVuY3Rpb24gb25SZWFkeShmbikge1xuICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdsb2FkaW5nJykge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQWxpYXMgZm9yIG9uUmVhZHlBbmRSZWZyZXNoLCB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIHVzZSBhbmQgZG9jdW1lbnQgdGhpcyBmdW5jdGlvbmFsaXR5XG4gIGFwb3MudXRpbC5vblJlYWR5ID0gYXBvcy51dGlsLm9uUmVhZHlBbmRSZWZyZXNoLmJpbmQoYXBvcy51dGlsLm9uUmVhZHlBbmRSZWZyZXNoKTtcblxuICAvLyBSdW4gYWxsIHRoZSBwbGF5ZXJzIHRoYXQgaGF2ZW4ndCBiZWVuIHJ1bi4gSW52b2tlZCBmb3IgeW91IGF0IERPTXJlYWR5XG4gIC8vIHRpbWUuIFlvdSBtYXkgYWxzbyBpbnZva2UgaXQgaWYgeW91IGp1c3QgQUpBWGVkIGluIHNvbWUgY29udGVudCBhbmRcbiAgLy8gaGF2ZSByZWFzb24gdG8gc3VzcGVjdCB0aGVyZSBjb3VsZCBiZSB3aWRnZXRzIGluIHRoZXJlLiBZb3UgbWF5IHBhc3M6XG4gIC8vXG4gIC8vICogTm90aGluZyBhdCBhbGwgLSBlbnRpcmUgZG9jdW1lbnQgaXMgc2VhcmNoZWQgZm9yIG5ldyB3aWRnZXRzIHRvIGVuaGFuY2UsIG9yXG4gIC8vICogQSBET00gZWxlbWVudCAtIG5ldyB3aWRnZXRzIHRvIGVuaGFuY2UgYXJlIGZvdW5kIHdpdGhpbiB0aGlzIHNjb3BlIG9ubHkuXG4gIC8vXG4gIC8vIFRvIHJlZ2lzdGVyIGEgd2lkZ2V0IHBsYXllciBmb3IgdGhlIGBhcG9zdHJvcGhlLWltYWdlc2Agd2lkZ2V0LCB3cml0ZTpcbiAgLy9cbiAgLy8gYGFwb3MudXRpbC53aWRnZXRQbGF5ZXJzWydhcG9zdHJvcGhlLWltYWdlcyddID0gZnVuY3Rpb24oZWwsIGRhdGEsIG9wdGlvbnMpIHsgLi4uIH1gXG4gIC8vXG4gIC8vIGBlbGAgaXMgYSBET00gZWxlbWVudCwgbm90IGEgalF1ZXJ5IG9iamVjdC4gT3RoZXJ3aXNlIGlkZW50aWNhbCB0b1xuICAvLyB0cmFkaXRpb25hbCBBcG9zdHJvcGhlIHdpZGdldCBwbGF5ZXJzLiBgZGF0YWAgY29udGFpbnMgdGhlIHByb3BlcnRpZXNcbiAgLy8gb2YgdGhlIHdpZGdldCBpdHNlbGYsIGBvcHRpb25zYCBjb250YWlucyB0aGUgb3B0aW9ucyB0aGF0IHdlcmVcbiAgLy8gcGFzc2VkIHRvIGl0IGF0IHRoZSBhcmVhIGxldmVsLlxuICAvL1xuICAvLyBZb3VyIHBsYXllciBpcyBndWFyYW50ZWVkIHRvIHJ1biBvbmx5IG9uY2UgcGVyIHdpZGdldC4gSGludDpcbiAgLy8gRE9OJ1QgdHJ5IHRvIGZpbmQgYWxsIHRoZSB3aWRnZXRzLiBETyBqdXN0IGVuaGFuY2UgYGVsYC5cbiAgLy8gVGhpcyBpcyBhIGNvbXB1dGVyIHNjaWVuY2UgcHJpbmNpcGxlIGtub3duIGFzIFwic2VwYXJhdGlvbiBvZiBjb25jZXJucy5cIlxuXG4gIGFwb3MudXRpbC5ydW5QbGF5ZXJzID0gZnVuY3Rpb24oZWwpIHtcbiAgICBjb25zdCBwbGF5ZXJzID0gYXBvcy51dGlsLndpZGdldFBsYXllcnM7XG4gICAgY29uc3QgcGxheWVyTGlzdCA9IE9iamVjdC5rZXlzKHBsYXllcnMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGF5ZXJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwbGF5ZXJPcHRzID0gcGxheWVyc1twbGF5ZXJMaXN0W2ldXTtcbiAgICAgIGNvbnN0IHBsYXllckVscyA9IChlbCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChwbGF5ZXJPcHRzLnNlbGVjdG9yKTtcblxuICAgICAgcGxheWVyRWxzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmIChlbC5hcG9zV2lkZ2V0UGxheWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBhbiBhY3R1YWwgcHJvcGVydHksIG5vdCBhIERPTSBhdHRyaWJ1dGUgb3JcbiAgICAgICAgLy8gXCJkYXRhXCIgcHJlZml4IHByb3BlcnR5LCB0byBhdm9pZCB0aGUgcHJvYmxlbSBvZlxuICAgICAgICAvLyBlbGVtZW50cyBjbG9uZWQgZnJvbSBpbm5lckhUTUwgYXBwZWFyaW5nIHRvIGhhdmVcbiAgICAgICAgLy8gYmVlbiBwbGF5ZWQgdG9vXG4gICAgICAgIGVsLmFwb3NXaWRnZXRQbGF5ZWQgPSB0cnVlO1xuICAgICAgICBwbGF5ZXJPcHRzLnBsYXllcihlbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2NoZWR1bGUgcnVuUGxheWVycyB0byBydW4gYXMgc29vbiBhcyB0aGUgZG9jdW1lbnQgaXMgcmVhZHksIGFuZCBhbHNvXG4gIC8vIHdoZW4gdGhlIHBhZ2UgaXMgcGFydGlhbGx5IHJlZnJlc2hlZCBieSB0aGUgZWRpdG9yLlxuXG4gIGlmICghYXBvcy5idXMpIHtcbiAgICBhcG9zLnV0aWwub25SZWFkeUFuZFJlZnJlc2goZnVuY3Rpb24oKSB7XG4gICAgICBhcG9zLnV0aWwucnVuUGxheWVycygpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gR2l2ZW4gYW4gYXR0YWNobWVudCBmaWVsZCB2YWx1ZSxcbiAgLy8gcmV0dXJuIHRoZSBmaWxlIFVSTC4gSWYgb3B0aW9ucy5zaXplIGlzIHNldCwgcmV0dXJuIHRoZSBVUkwgZm9yXG4gIC8vIHRoYXQgc2l6ZSAob25lLXNpeHRoLCBvbmUtdGhpcmQsIG9uZS1oYWxmLCB0d28tdGhpcmRzLCBmdWxsLCBtYXgpLlxuICAvLyBmdWxsIGlzIFwiZnVsbCB3aWR0aFwiICgxMTQwcHgpLCBub3QgdGhlIG9yaWdpbmFsLlxuICAvL1xuICAvLyBJZiB5b3UgZG9uJ3QgcGFzcyB0aGUgb3B0aW9ucyBvYmplY3QsIG9yIG9wdGlvbnMgZG9lcyBub3RcbiAgLy8gaGF2ZSBhIHNpemUgcHJvcGVydHksIHlvdSdsbCBnZXQgdGhlIFVSTCBvZiB0aGUgb3JpZ2luYWwuXG4gIC8vIElNUE9SVEFOVDogRk9SIElNQUdFUywgVEhJUyBNQVkgQkUgQSBWRVJZIExBUkdFIEZJTEUsIE5PVFxuICAvLyBXSEFUIFlPVSBXQU5ULiBTZXQgYHNpemVgIGFwcHJvcHJpYXRlbHkhXG4gIC8vXG4gIC8vIFlvdSBjYW4gYWxzbyBwYXNzIGEgY3JvcCBvYmplY3QgKHRoZSBjcm9wIG11c3QgYWxyZWFkeSBleGlzdCkuXG5cbiAgYXBvcy51dGlsLmF0dGFjaG1lbnRVcmwgPSBmdW5jdGlvbihmaWxlLCBvcHRpb25zKSB7XG4gICAgbGV0IHBhdGggPSBhcG9zLnVwbG9hZHNVcmwgKyAnL2F0dGFjaG1lbnRzLycgKyBmaWxlLl9pZCArICctJyArIGZpbGUubmFtZTtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgLy8gTk9URTogdGhlIGNyb3AgbXVzdCBhY3R1YWxseSBleGlzdCBhbHJlYWR5LCB5b3UgY2FuJ3QganVzdCBpbnZlbnQgdGhlbVxuICAgIC8vIGJyb3dzZXItc2lkZSB3aXRob3V0IHRoZSBjcm9wIEFQSSBldmVyIGhhdmluZyBjb21lIGludG8gcGxheS4gSWYgdGhlXG4gICAgLy8gd2lkdGggaXMgMCB0aGUgdXNlciBoaXQgc2F2ZSBpbiB0aGUgY3JvcHBlciB3aXRob3V0IGNyb3BwaW5nLCB1c2VcbiAgICAvLyB0aGUgcmVndWxhciB2ZXJzaW9uXG4gICAgbGV0IGNyb3A7XG4gICAgaWYgKG9wdGlvbnMuY3JvcCAmJiBvcHRpb25zLmNyb3Aud2lkdGgpIHtcbiAgICAgIGNyb3AgPSBvcHRpb25zLmNyb3A7XG4gICAgfSBlbHNlIGlmIChmaWxlLmNyb3AgJiYgZmlsZS5jcm9wLndpZHRoKSB7XG4gICAgICBjcm9wID0gZmlsZS5jcm9wO1xuICAgIH1cbiAgICBpZiAoY3JvcCkge1xuICAgICAgcGF0aCArPSAnLicgKyBjcm9wLmxlZnQgKyAnLicgKyBjcm9wLnRvcCArICcuJyArIGNyb3Aud2lkdGggKyAnLicgKyBjcm9wLmhlaWdodDtcbiAgICB9XG4gICAgbGV0IGVmZmVjdGl2ZVNpemU7XG4gICAgaWYgKCghb3B0aW9ucy5zaXplKSB8fCAob3B0aW9ucy5zaXplID09PSAnb3JpZ2luYWwnKSkge1xuICAgICAgZWZmZWN0aXZlU2l6ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZmZlY3RpdmVTaXplID0gb3B0aW9ucy5zaXplO1xuICAgIH1cbiAgICBpZiAoZWZmZWN0aXZlU2l6ZSkge1xuICAgICAgcGF0aCArPSAnLicgKyBlZmZlY3RpdmVTaXplO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aCArICcuJyArIGZpbGUuZXh0ZW5zaW9uO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgdXJpIHJlZmVyZW5jZXMgdGhlIHNhbWUgc2l0ZSAoc2FtZSBob3N0IGFuZCBwb3J0KSBhcyB0aGVcbiAgLy8gY3VycmVudCBwYWdlLiBDcm9zcy1icm93c2VyIGltcGxlbWVudGF0aW9uLCB2YWxpZCBhdCBsZWFzdCBiYWNrIHRvIElFMTEuXG4gIC8vIFJlZ2FyZGluZyBwb3J0IG51bWJlcnMsIHRoaXMgd2lsbCBtYXRjaCBhcyBsb25nIGFzIHRoZSBVUklzIGFyZSBjb25zaXN0ZW50XG4gIC8vIGFib3V0IG5vdCBleHBsaWNpdGx5IHNwZWNpZnlpbmcgdGhlIHBvcnQgbnVtYmVyIHdoZW4gaXQgaXMgODAgKEhUVFApIG9yIDQ0MyAoSFRUUFMpLFxuICAvLyB3aGljaCBpcyBnZW5lcmFsbHkgdGhlIGNhc2UuXG5cbiAgYXBvcy51dGlsLnNhbWVTaXRlID0gZnVuY3Rpb24odXJpKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHVyaS5tYXRjaCgvXihodHRwcz86KT9cXC9cXC8oW14vXSspLyk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAvLyBJZiBVUkkgaXMgbm90IGFic29sdXRlIG9yIHByb3RvY29sLXJlbGF0aXZlIHRoZW4gaXQgaXMgYWx3YXlzIHNhbWUtb3JpZ2luXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5ob3N0ID09PSBtYXRjaGVzWzJdO1xuICB9O1xufTtcbiIsImV4cG9ydCBkZWZhdWx0ICgpID0+IHtcbiAgLy8gQWRkcyB0aGUgYXBvcy5odHRwIGNsaWVudCwgd2hpY2ggaGFzIHRoZSBzYW1lIEFQSVxuICAvLyBhcyB0aGUgc2VydmVyLXNpZGUgYXBvcy5odHRwIGNsaWVudCwgYWx0aG91Z2ggaXQgbWF5XG4gIC8vIG5vdCBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZmVhdHVyZXMgYXZhaWxhYmxlLlxuICAvLyBUaGlzIGlzIGEgbGVhbiwgSUUxMS1mcmllbmRseSBpbXBsZW1lbnRhdGlvbi5cblxuICBjb25zdCBidXN5QWN0aXZlID0ge307XG4gIGNvbnN0IGFwb3MgPSB3aW5kb3cuYXBvcztcbiAgYXBvcy5odHRwID0ge307XG5cbiAgLy8gU2VuZCBhIFBPU1QgcmVxdWVzdC4gTm90ZSB0aGF0IFBPU1QgYm9keSBkYXRhIHNob3VsZCBiZSBpblxuICAvLyBgb3B0aW9ucy5ib2R5YC4gU2VlIGBhcG9zLmh0dHAucmVtb3RlYCBmb3IgZGV0YWlscy5cbiAgLy8gWW91IGRvIE5PVCBoYXZlIHRvIHBhc3MgYSBjYWxsYmFjayB1bmxlc3MgeW91IG11c3Qgc3VwcG9ydCBJRTExXG4gIC8vIGFuZCBkbyBub3Qgd2FudCB0byBpbmNsdWRlIGEgcHJvbWlzZSBwb2x5ZmlsbCBpbiB5b3VyIGJ1aWxkLlxuXG4gIGFwb3MuaHR0cC5wb3N0ID0gZnVuY3Rpb24odXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBhcG9zLmh0dHAucmVtb3RlKCdQT1NUJywgdXJsLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLy8gU2VuZCBhIEdFVCByZXF1ZXN0LiBOb3RlIHRoYXQgcXVlcnkgc3RyaW5nIGRhdGEgbWF5IGJlIGluXG4gIC8vIGBvcHRpb25zLnFzYC4gU2VlIGBhcG9zLmh0dHAucmVtb3RlYCBmb3IgZGV0YWlscy5cbiAgLy8gWW91IGRvIE5PVCBoYXZlIHRvIHBhc3MgYSBjYWxsYmFjayB1bmxlc3MgeW91IG11c3Qgc3VwcG9ydCBJRTExXG4gIC8vIGFuZCBkbyBub3Qgd2FudCB0byBpbmNsdWRlIGEgcHJvbWlzZSBwb2x5ZmlsbCBpbiB5b3VyIGJ1aWxkLlxuICBhcG9zLmh0dHAuZ2V0ID0gZnVuY3Rpb24odXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBhcG9zLmh0dHAucmVtb3RlKCdHRVQnLCB1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvLyBTZW5kIGEgUEFUQ0ggcmVxdWVzdC4gTm90ZSB0aGF0IFBBVENIIGJvZHkgZGF0YSBzaG91bGQgYmUgaW5cbiAgLy8gYG9wdGlvbnMuYm9keWAuIFNlZSBgYXBvcy5odHRwLnJlbW90ZWAgZm9yIGRldGFpbHMuXG4gIC8vIFlvdSBkbyBOT1QgaGF2ZSB0byBwYXNzIGEgY2FsbGJhY2sgdW5sZXNzIHlvdSBtdXN0IHN1cHBvcnQgSUUxMVxuICAvLyBhbmQgZG8gbm90IHdhbnQgdG8gaW5jbHVkZSBhIHByb21pc2UgcG9seWZpbGwgaW4geW91ciBidWlsZC5cbiAgYXBvcy5odHRwLnBhdGNoID0gZnVuY3Rpb24odXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBhcG9zLmh0dHAucmVtb3RlKCdQQVRDSCcsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8vIFNlbmQgYSBQVVQgcmVxdWVzdC4gTm90ZSB0aGF0IFBVVCBib2R5IGRhdGEgc2hvdWxkIGJlIGluXG4gIC8vIGBvcHRpb25zLmJvZHlgLiBTZWUgYGFwb3MuaHR0cC5yZW1vdGVgIGZvciBkZXRhaWxzLlxuICAvLyBZb3UgZG8gTk9UIGhhdmUgdG8gcGFzcyBhIGNhbGxiYWNrIHVubGVzcyB5b3UgbXVzdCBzdXBwb3J0IElFMTFcbiAgLy8gYW5kIGRvIG5vdCB3YW50IHRvIGluY2x1ZGUgYSBwcm9taXNlIHBvbHlmaWxsIGluIHlvdXIgYnVpbGQuXG4gIGFwb3MuaHR0cC5wdXQgPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGFwb3MuaHR0cC5yZW1vdGUoJ1BVVCcsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8vIFNlbmQgYSBERUxFVEUgcmVxdWVzdC4gU2VlIGBhcG9zLmh0dHAucmVtb3RlYCBmb3IgZGV0YWlscy5cbiAgLy8gWW91IGRvIE5PVCBoYXZlIHRvIHBhc3MgYSBjYWxsYmFjayB1bmxlc3MgeW91IG11c3Qgc3VwcG9ydCBJRTExXG4gIC8vIGFuZCBkbyBub3Qgd2FudCB0byBpbmNsdWRlIGEgcHJvbWlzZSBwb2x5ZmlsbCBpbiB5b3VyIGJ1aWxkLlxuICBhcG9zLmh0dHAuZGVsZXRlID0gZnVuY3Rpb24odXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBhcG9zLmh0dHAucmVtb3RlKCdERUxFVEUnLCB1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvLyBTZW5kIGFuIEhUVFAgcmVxdWVzdCB3aXRoIHRoZSBnaXZlbiBtZXRob2QgdG8gdGhlIGdpdmVuIFVSTCBhbmQgcmV0dXJuIHRoZSByZXNwb25zZSBib2R5LlxuICAvL1xuICAvLyBUaGUgY2FsbGJhY2sgaXMgb3B0aW9uYWwgYXMgbG9uZyBhcyBQcm9taXNlIHN1cHBvcnQgaXMgcHJlc2VudCBpbiB0aGUgYnJvd3NlciwgZGlyZWN0bHkgb3IgYXNcbiAgLy8gYSBwb2x5ZmlsbC4gSWYgYSBjYWxsYmFjayBpcyB1c2VkIGl0IHdpbGwgcmVjZWl2ZSBgKGVyciwgcmVzdWx0KWAgd2hlcmUgYHJlc3VsdGAgaXMgdGhlXG4gIC8vIHJldHVybiB2YWx1ZSBkZXNjcmliZWQgYmVsb3cuXG4gIC8vXG4gIC8vIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuICAvL1xuICAvLyBgcXNgIChwYXNzIG9iamVjdDsgYnVpbGRzIGEgcXVlcnkgc3RyaW5nLCBkb2VzIG5vdCBzdXBwb3J0IHJlY3Vyc2lvbilcbiAgLy8gYHNlbmRgOiBieSBkZWZhdWx0LCBgb3B0aW9ucy5ib2R5YCBpcyBzZW50IGFzIEpTT04gaWYgaXQgaXMgYW4gb2JqZWN0IGFuZCBpdCBpcyBub3QgYVxuICAvLyBgRm9ybURhdGFgIG9iamVjdC4gSWYgYHNlbmRgIGlzIHNldCB0byBganNvbmAsIGl0IGlzIGFsd2F5cyBzZW50IGFzIEpTT04uXG4gIC8vIGBib2R5YCAocmVxdWVzdCBib2R5LCBub3QgZm9yIEdFVDsgaWYgYW4gb2JqZWN0IG9yIGFycmF5LCBzZW50IGFzIEpTT04sIG90aGVyd2lzZSBzZW50IGFzLWlzLCB1bmxlc3NcbiAgLy8gdGhlIGBzZW5kYCBvcHRpb24gaXMgc2V0KVxuICAvLyBgcGFyc2VgIChjYW4gYmUgJ2pzb25gIHRvIGFsd2F5cyBwYXJzZSB0aGUgcmVzcG9uc2UgYm9keSBhcyBKU09OLCBvdGhlcndpc2UgdGhlIHJlc3BvbnNlIGJvZHkgaXNcbiAgLy8gcGFyc2VkIGFzIEpTT04gb25seSBpZiB0aGUgY29udGVudC10eXBlIGlzIGFwcGxpY2F0aW9uL2pzb24pXG4gIC8vIGBoZWFkZXJzYCAoYW4gb2JqZWN0IGNvbnRhaW5pbmcgaGVhZGVyIG5hbWVzIGFuZCB2YWx1ZXMpXG4gIC8vIGBkcmFmdGAgKGlmIHRydWUsIGFsd2F5cyBhZGQgYXBvc01vZGU9ZHJhZnQgdG8gdGhlIHF1ZXJ5IHN0cmluZywgY3JlYXRpbmcgb25lIGlmIG5lZWRlZClcbiAgLy8gYGNzcmZgICh1bmxlc3MgZXhwbGljaXRseSBzZXQgdG8gYGZhbHNlYCwgc2VuZCB0aGUgWC1YU1JGLVRPS0VOIGhlYWRlciB3aGVuIHRhbGtpbmcgdG8gdGhlIHNhbWUgc2l0ZSlcbiAgLy8gYGZ1bGxSZXNwb25zZWAgKGlmIHRydWUsIHJldHVybiBhbiBvYmplY3Qgd2l0aCBgc3RhdHVzYCwgYGhlYWRlcnNgIGFuZCBgYm9keWBcbiAgLy8gcHJvcGVydGllcywgcmF0aGVyIHRoYW4gcmV0dXJuaW5nIHRoZSBib2R5IGRpcmVjdGx5OyB0aGUgaW5kaXZpZHVhbCBgaGVhZGVyc2AgYXJlIGNhbm9uaWNhbGl6ZWRcbiAgLy8gdG8gbG93ZXJjYXNlIG5hbWVzLiBJZiB0aGVyZSBhcmUgZHVwbGljYXRlIGhlYWRlcnMgYWZ0ZXIgY2Fub25pY2FsaXphdGlvbiBvbmx5IHRoZVxuICAvLyBsYXN0IHZhbHVlIGlzIHJldHVybmVkLiBJZiBhIGhlYWRlciBhcHBlYXJzIG11bHRpcGxlIHRpbWVzIGFuIGFycmF5IGlzIHJldHVybmVkIGZvciBpdClcbiAgLy8gYGRvd25sb2FkUHJvZ3Jlc3NgIChtYXkgYmUgYSBmdW5jdGlvbiBhY2NlcHRpbmcgYHJlY2VpdmVkYCBhbmQgYHRvdGFsYCBwYXJhbWV0ZXJzLiBNYXkgbmV2ZXIgYmUgY2FsbGVkLiBJZlxuICAvLyBjYWxsZWQsIGByZWNlaXZlZGAgd2lsbCBiZSB0aGUgYnl0ZXMgc2VudCBzbyBmYXIsIGFuZCBgdG90YWxgIHdpbGwgYmUgdGhlIHRvdGFsIGJ5dGVzIHRvIGJlXG4gIC8vIHJlY2VpdmVkLiBJZiB0aGUgdG90YWwgaXMgdW5rbm93biwgaXQgd2lsbCBiZSBgbnVsbGApXG4gIC8vIGB1cGxvYWRQcm9ncmVzc2AgKG1heSBiZSBhIGZ1bmN0aW9uIGFjY2VwdGluZyBgc2VudGAgYW5kIGB0b3RhbGAgcGFyYW1ldGVycy4gTWF5IG5ldmVyIGJlIGNhbGxlZC4gSWZcbiAgLy8gY2FsbGVkLCBgc2VudGAgd2lsbCBiZSB0aGUgYnl0ZXMgc2VudCBzbyBmYXIsIGFuZCBgdG90YWxgIHdpbGwgYmUgdGhlIHRvdGFsIGJ5dGVzIHRvIGJlXG4gIC8vIHNlbnQuIElmIHRoZSB0b3RhbCBpcyB1bmtub3duLCBpdCB3aWxsIGJlIGBudWxsYClcbiAgLy9cbiAgLy8gSWYgdGhlIHN0YXR1cyBjb2RlIGlzID49IDQwMCBhbiBlcnJvciBpcyB0aHJvd24uIFRoZSBlcnJvciBvYmplY3Qgd2lsbCBiZVxuICAvLyBzaW1pbGFyIHRvIGEgYGZ1bGxSZXNwb25zZWAgb2JqZWN0LCB3aXRoIGEgYHN0YXR1c2AgcHJvcGVydHkuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgc2l0ZS1yZWxhdGl2ZSAoc3RhcnRzIHdpdGggLykgaXQgd2lsbCBiZSByZXF1ZXN0ZWQgZnJvbVxuICAvLyB0aGUgYXBvc3Ryb3BoZSBzaXRlIGl0c2VsZi5cblxuICAvLyBKdXN0IGJlZm9yZSB0aGUgWE1MSFRUUFJlcXVlc3QgaXMgc2VudCB0aGlzIG1ldGhvZCBlbWl0cyBhblxuICAvLyBgYXBvcy1iZWZvcmUtcG9zdGAgZXZlbnQgb24gYGRvY3VtZW50LmJvZHlgICh3aGVyZSBgcG9zdGAgY2hhbmdlc1xuICAvLyB0byBtYXRjaCB0aGUgbWV0aG9kLCBpbiBsb3dlciBjYXNlKS4gVGhlIGV2ZW50IG9iamVjdFxuICAvLyBoYXMgYHVyaWAsIGBkYXRhYCBhbmQgYHJlcXVlc3RgIHByb3BlcnRpZXMuIGByZXF1ZXN0YCBpcyB0aGVcbiAgLy8gWE1MSFRUUFJlcXVlc3Qgb2JqZWN0LiBZb3UgY2FuIHVzZSB0aGlzIHRvIHNldCBjdXN0b20gaGVhZGVyc1xuICAvLyBvbiBhbGwgbGVhbiByZXF1ZXN0cywgZXRjLlxuXG4gIGFwb3MuaHR0cC5yZW1vdGUgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBpZiAoIXdpbmRvdy5Qcm9taXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWYgeW91IHdpc2ggdG8gcmVjZWl2ZSBhIHByb21pc2UgZnJvbSBhcG9zLmh0dHAgbWV0aG9kcyBpbiBvbGRlciBicm93c2VycyB5b3UgbXVzdCBoYXZlIGEgUHJvbWlzZSBwb2x5ZmlsbC4gSWYgeW91IGRvIG5vdCB3YW50IHRvIHByb3ZpZGUgb25lLCBwYXNzIGEgY2FsbGJhY2sgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgd2luZG93LlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJldHVybiBhcG9zLmh0dHAucmVtb3RlKG1ldGhvZCwgdXJsLCBvcHRpb25zLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYXBvcy5wcmVmaXgpIHtcbiAgICAgIC8vIFdlIGRvbid0IG5lZWQgYSBwcmVmaXggaWYgdGhlIHRhcmdldCBVUkwgaXMgYWxyZWFkeSBwcmVmaXhlZCxcbiAgICAgIC8vIHdoaWNoIGFueSBhYnNvbHV0ZSBVUkwgc2hvdWxkIGJlXG4gICAgICBpZiAodXJsLnN1YnN0cmluZygwLCAxKSA9PT0gJy8nKSB7XG4gICAgICAgIHVybCA9IGFwb3MucHJlZml4ICsgdXJsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBxdWVyeTtcbiAgICBsZXQgcWF0O1xuXG4gICAgLy8gSW50ZW50aW9uYWwgdHJ1ZSAvIGZhbHNleSBjaGVjayBmb3IgZGV0ZXJtaW5pbmdcbiAgICAvLyB3aGF0IHNldCBvZiBkb2NzIHRoZSByZXF1ZXN0IGlzIGludGVyZXN0ZWQgaW5cbiAgICBpZiAob3B0aW9ucy5kcmFmdCAhPSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5xcykge1xuICAgICAgICAvLyBBbHJlYWR5IGFzc3VtZXMgbm8gcXVlcnkgcGFyYW1ldGVycyBiYWtlZCBpbnRvIFVSTCwgc28gT0sgdG9cbiAgICAgICAgLy8ganVzdCBleHRlbmQgcXNcbiAgICAgICAgb3B0aW9ucy5xcyA9IG9wdGlvbnMuZHJhZnRcbiAgICAgICAgICA/IGFwb3MudXRpbC5hc3NpZ24oeyBhcG9zTW9kZTogJ2RyYWZ0JyB9LCBvcHRpb25zLnFzKVxuICAgICAgICAgIDogYXBvcy51dGlsLmFzc2lnbih7IGFwb3NNb2RlOiAncHVibGlzaGVkJyB9LCBvcHRpb25zLnFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENhcmVmdWwsIHRoZXJlIGNvdWxkIGJlIGV4aXN0aW5nIHF1ZXJ5IHBhcmFtZXRlcnMgYmFrZWQgaW50byB1cmxcbiAgICAgICAgcWF0ID0gdXJsLmluZGV4T2YoJz8nKTtcbiAgICAgICAgaWYgKHFhdCAhPT0gLTEpIHtcbiAgICAgICAgICBxdWVyeSA9IGFwb3MuaHR0cC5wYXJzZVF1ZXJ5KHVybC5zdWJzdHJpbmcocWF0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVlcnkgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBxdWVyeS5hcG9zTW9kZSA9IG9wdGlvbnMuZHJhZnQgPyAnZHJhZnQnIDogJ3B1Ymxpc2hlZCc7XG4gICAgICAgIHVybCA9IGFwb3MuaHR0cC5hZGRRdWVyeVRvVXJsKHVybCwgcXVlcnkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJ1c3lOYW1lID0gb3B0aW9ucy5idXN5ID09PSB0cnVlID8gJ2J1c3knIDogb3B0aW9ucy5idXN5O1xuICAgIGNvbnN0IHhtbGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBjb25zdCBjc3JmVG9rZW4gPSBhcG9zLmNzcmZDb29raWVOYW1lID8gYXBvcy51dGlsLmdldENvb2tpZShhcG9zLmNzcmZDb29raWVOYW1lKSA6ICdjc3JmLWZhbGxiYWNrJztcbiAgICBsZXQgZGF0YSA9IG9wdGlvbnMuYm9keTtcbiAgICBsZXQga2V5cztcbiAgICBsZXQgaTtcbiAgICBpZiAob3B0aW9ucy5xcykge1xuICAgICAgdXJsID0gYXBvcy5odHRwLmFkZFF1ZXJ5VG9VcmwodXJsLCBvcHRpb25zLnFzKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYnVzeSkge1xuICAgICAgaWYgKCFidXN5QWN0aXZlW2J1c3lOYW1lXSkge1xuICAgICAgICBidXN5QWN0aXZlW2J1c3lOYW1lXSA9IDA7XG4gICAgICAgIGFwb3MuYnVzLiRlbWl0KCdidXN5Jywge1xuICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICBuYW1lOiBidXN5TmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIGtlZXAgdHJhY2sgb2YgbmVzdGVkIGNhbGxzXG4gICAgICBidXN5QWN0aXZlW2J1c3lOYW1lXSsrO1xuICAgIH1cbiAgICB4bWxodHRwLm9wZW4obWV0aG9kLCB1cmwpO1xuICAgIGNvbnN0IGZvcm1EYXRhID0gd2luZG93LkZvcm1EYXRhICYmIChkYXRhIGluc3RhbmNlb2Ygd2luZG93LkZvcm1EYXRhKTtcbiAgICBjb25zdCBzZW5kSnNvbiA9IChvcHRpb25zLnNlbmQgPT09ICdqc29uJykgfHwgKG9wdGlvbnMuYm9keSAmJiAoKHR5cGVvZiBvcHRpb25zLmJvZHkpID09PSAnb2JqZWN0JykgJiYgIWZvcm1EYXRhKTtcbiAgICBpZiAoc2VuZEpzb24pIHtcbiAgICAgIHhtbGh0dHAuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICB9XG4gICAgaWYgKGNzcmZUb2tlbiAmJiAob3B0aW9ucy5jc3JmICE9PSBmYWxzZSkpIHtcbiAgICAgIGlmIChhcG9zLnV0aWwuc2FtZVNpdGUodXJsKSkge1xuICAgICAgICB4bWxodHRwLnNldFJlcXVlc3RIZWFkZXIoJ1gtWFNSRi1UT0tFTicsIGNzcmZUb2tlbik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgZm9yIChpID0gMDsgKGkgPCBrZXlzLmxlbmd0aCk7IGkrKykge1xuICAgICAgICB4bWxodHRwLnNldFJlcXVlc3RIZWFkZXIoa2V5c1tpXSwgb3B0aW9ucy5oZWFkZXJzW2tleXNbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXBvcy51dGlsLmVtaXQoZG9jdW1lbnQuYm9keSwgJ2Fwb3MtYmVmb3JlLScgKyBtZXRob2QudG9Mb3dlckNhc2UoKSwge1xuICAgICAgdXJpOiB1cmwsXG4gICAgICBkYXRhOiBvcHRpb25zLmJvZHksXG4gICAgICByZXF1ZXN0OiB4bWxodHRwXG4gICAgfSk7XG4gICAgaWYgKHNlbmRKc29uKSB7XG4gICAgICBkYXRhID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IG9wdGlvbnMuYm9keTtcbiAgICB9XG4gICAgeG1saHR0cC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgZGF0YSA9IG51bGw7XG4gICAgICBjb25zdCByZXNwb25zZUhlYWRlciA9IHRoaXMuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgaWYgKHJlc3BvbnNlSGVhZGVyIHx8IChvcHRpb25zLnBhcnNlID09PSAnanNvbicpKSB7XG4gICAgICAgIGlmICgob3B0aW9ucy5wYXJzZSA9PT0gJ2pzb24nKSB8fCAocmVzcG9uc2VIZWFkZXIubWF0Y2goL15hcHBsaWNhdGlvblxcL2pzb24vKSkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UodGhpcy5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YSA9IHRoaXMucmVzcG9uc2VUZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh4bWxodHRwLnN0YXR1cyA8IDQwMCkge1xuICAgICAgICBpZiAob3B0aW9ucy5mdWxsUmVzcG9uc2UpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgYm9keTogZGF0YSxcbiAgICAgICAgICAgIHN0YXR1czogeG1saHR0cC5zdGF0dXMsXG4gICAgICAgICAgICBoZWFkZXJzOiBnZXRIZWFkZXJzKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKChkYXRhICYmIGRhdGEubWVzc2FnZSkgfHwgKGRhdGEgJiYgZGF0YS5uYW1lKSB8fCAnRXJyb3InKTtcbiAgICAgICAgZXJyb3Iuc3RhdHVzID0geG1saHR0cC5zdGF0dXM7XG4gICAgICAgIGVycm9yLm5hbWUgPSAoZGF0YSAmJiBkYXRhLm5hbWUpO1xuICAgICAgICBlcnJvci5ib2R5ID0gZGF0YTtcbiAgICAgICAgZXJyb3IuaGVhZGVycyA9IGdldEhlYWRlcnMoKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB4bWxodHRwLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXZ0KTtcbiAgICB9KTtcbiAgICB4bWxodHRwLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXZ0KTtcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5kb3dubG9hZFByb2dyZXNzKSB7XG4gICAgICB4bWxodHRwLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIG9wdGlvbnMuZG93bmxvYWRQcm9ncmVzcyhldnQubG9hZGVkLCBldnQubGVuZ3RoQ29tcHV0YWJsZSA/IGV2dC50b3RhbCA6IG51bGwpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh4bWxodHRwLnVwbG9hZCAmJiBvcHRpb25zLnVwbG9hZFByb2dyZXNzKSB7XG4gICAgICB4bWxodHRwLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBvcHRpb25zLnVwbG9hZFByb2dyZXNzKGV2dC5sb2FkZWQsIGV2dC5sZW5ndGhDb21wdXRhYmxlID8gZXZ0LnRvdGFsIDogbnVsbCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgeG1saHR0cC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgaWYgKG9wdGlvbnMuYnVzeSkge1xuICAgICAgICBidXN5QWN0aXZlW2J1c3lOYW1lXS0tO1xuICAgICAgICBpZiAoIWJ1c3lBY3RpdmVbYnVzeU5hbWVdKSB7XG4gICAgICAgICAgLy8gaWYgbm8gbmVzdGVkIGNhbGxzLCBkaXNhYmxlIHRoZSBcImJ1c3lcIiBzdGF0ZVxuICAgICAgICAgIGFwb3MuYnVzLiRlbWl0KCdidXN5Jywge1xuICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG5hbWU6IGJ1c3lOYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB4bWxodHRwLnNlbmQoZGF0YSk7XG5cbiAgICBmdW5jdGlvbiBnZXRIZWFkZXJzKCkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHhtbGh0dHAuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG4gICAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgLy8gUGVyIE1ETlxuICAgICAgY29uc3QgYXJyID0gaGVhZGVycy50cmltKCkuc3BsaXQoL1tcXHJcXG5dKy8pO1xuICAgICAgLy8gQ3JlYXRlIGEgbWFwIG9mIGhlYWRlciBuYW1lcyB0byB2YWx1ZXNcbiAgICAgIGNvbnN0IGhlYWRlck1hcCA9IHt9O1xuICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCc6ICcpO1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICBpZiAoIWhlYWRlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIC8vIE9wdGlvbmFsIHN1cHBvcnQgZm9yIGZldGNoaW5nIGFycmF5cyBvZiBoZWFkZXJzIHdpdGggdGhlIHNhbWUgbmFtZVxuICAgICAgICAvLyBjb3VsZCBiZSBhZGRlZCBhdCBhIGxhdGVyIHRpbWUgaWYgYW55b25lIHJlYWxseSBjYXJlcy4gVXN1YWxseVxuICAgICAgICAvLyBqdXN0IGEgc291cmNlIG9mIGJ1Z3NcbiAgICAgICAgaGVhZGVyTWFwW2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaGVhZGVyTWFwO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXJzZSBhIHF1ZXJ5IHN0cmluZy4gWW91IGNhbiBwYXNzIHdpdGggb3Igd2l0aG91dCB0aGVcbiAgLy8gbGVhZGluZyA/LiBEb24ndCBwYXNzIHRoZSBlbnRpcmUgVVJMLiBTdXBwb3J0cyBvYmplY3RzLFxuICAvLyBhcnJheXMgYW5kIG5lc3Rpbmcgd2l0aCB0aGUgY2xhc3NpYyBQSFAvSmF2YSBicmFja2V0IHN5bnRheC5cbiAgLy8gSWYgYSBrZXkgaXMgc2V0IHdpdGggbm8gPSBpdCBpcyBjb25zaWRlcmVkIG51bGwsIHBlclxuICAvLyB0aGUgamF2YSBjb252ZW50aW9uLiBHb29kIGZvciB1c2Ugd2l0aCB3aW5kb3cubG9jYXRpb24uc2VhcmNoLlxuXG4gIGFwb3MuaHR0cC5wYXJzZVF1ZXJ5ID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5LnJlcGxhY2UoL15cXD8vLCAnJyk7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGNvbnN0IHBhaXJzID0gcXVlcnkuc3BsaXQoJyYnKTtcbiAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgIGxldCBwYXJ0cztcbiAgICAgIGlmIChwYWlyLmluZGV4T2YoJz0nKSA9PT0gLTEpIHtcbiAgICAgICAgcGF0Y2gocGFpciwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cyA9IHBhaXIuc3BsaXQoJz0nKTtcbiAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgcGF0Y2gocGFydHNbMF0sIHBhcnRzWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhLnJvb3QgfHwge307XG4gICAgZnVuY3Rpb24gcGF0Y2goa2V5LCB2YWx1ZSkge1xuICAgICAgbGV0IG1hdGNoO1xuICAgICAgbGV0IHBhcmVudEtleSA9ICdyb290JztcbiAgICAgIGxldCBjb250ZXh0ID0gZGF0YTtcbiAgICAgIGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXkpO1xuICAgICAgY29uc3QgcGF0aCA9IGtleS5zcGxpdCgnWycpO1xuICAgICAgcGF0aC5mb3JFYWNoKGZ1bmN0aW9uKHN1YktleSkge1xuICAgICAgICBpZiAoc3ViS2V5ID09PSAnXScpIHtcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29udGV4dFtwYXJlbnRLZXldKSkge1xuICAgICAgICAgICAgY29udGV4dFtwYXJlbnRLZXldID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0W3BhcmVudEtleV07XG4gICAgICAgICAgcGFyZW50S2V5ID0gY29udGV4dC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoc3ViS2V5Lm1hdGNoKC9eXFxkK10vKSkge1xuICAgICAgICAgIG1hdGNoID0gc3ViS2V5Lm1hdGNoKC9eXFxkKy8pO1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb250ZXh0W3BhcmVudEtleV0pKSB7XG4gICAgICAgICAgICBjb250ZXh0W3BhcmVudEtleV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGV4dCA9IGNvbnRleHRbcGFyZW50S2V5XTtcbiAgICAgICAgICBwYXJlbnRLZXkgPSBwYXJzZUludChtYXRjaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2ggPSBzdWJLZXkucmVwbGFjZSgnXScsICcnKTtcbiAgICAgICAgICBpZiAoIWNvbnRleHRbcGFyZW50S2V5XSkge1xuICAgICAgICAgICAgY29udGV4dFtwYXJlbnRLZXldID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0W3BhcmVudEtleV07XG4gICAgICAgICAgcGFyZW50S2V5ID0gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFsdWUgPSAodmFsdWUgPT09IG51bGwpID8gdmFsdWUgOiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGV4dFtwYXJlbnRLZXldKSkge1xuICAgICAgICBjb250ZXh0W3BhcmVudEtleV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHRbcGFyZW50S2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRleHRbcGFyZW50S2V5XSA9IFsgY29udGV4dFtwYXJlbnRLZXldLCB2YWx1ZSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dFtwYXJlbnRLZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEFkZHMgcXVlcnkgc3RyaW5nIGRhdGEgdG8gdXJsLiBTdXBwb3J0cyBuZXN0ZWQgc3RydWN0dXJlcyB3aXRoIG9iamVjdHNcbiAgLy8gYW5kIGFycmF5cywgaW4gYSB3YXkgY29tcGF0aWJsZSB3aXRoIHFzIGFuZCBtb3N0IG90aGVyIHBhcnNlcnMgaW5jbHVkaW5nXG4gIC8vIHRob3NlIGJha2VkIGludG8gUEhQIGZyYW1ld29ya3MgZXRjLiBJZiB0aGUgVVJMIGFscmVhZHkgY29udGFpbnMgYSBxdWVyeVxuICAvLyBpdCBpcyBkaXNjYXJkZWQgYW5kIHJlcGxhY2VkIHdpdGggdGhlIG5ldyBvbmUuIEFsbCBub24tcXVlcnkgcGFydHMgb2YgdGhlXG4gIC8vIFVSTCByZW1haW4gdW5jaGFuZ2VkLlxuXG4gIGFwb3MuaHR0cC5hZGRRdWVyeVRvVXJsID0gZnVuY3Rpb24odXJsLCBkYXRhKSB7XG4gICAgbGV0IGhhc2ggPSAnJztcbiAgICBjb25zdCBoYXNoQXQgPSB1cmwuaW5kZXhPZignIycpO1xuICAgIGlmIChoYXNoQXQgIT09IC0xKSB7XG4gICAgICBoYXNoID0gdXJsLnN1YnN0cmluZyhoYXNoQXQpO1xuICAgICAgdXJsID0gdXJsLnN1YnN0cmluZygwLCBoYXNoQXQpO1xuICAgIH1cbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvXFw/LiokLywgJycpO1xuICAgIGxldCBpO1xuICAgIGxldCBmbGF0O1xuICAgIGlmICgoZGF0YSAhPSBudWxsKSAmJiAoKHR5cGVvZiBkYXRhKSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICBmbGF0ID0gZmxhdHRlbignJywgZGF0YSk7XG4gICAgICBmb3IgKGkgPSAwOyAoaSA8IGZsYXQubGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGZsYXRbaV1bMF07XG4gICAgICAgIGNvbnN0IHZhbCA9IGZsYXRbaV1bMV07XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHVybCArPSAnJic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsICs9ICc/JztcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAvLyBKYXZhLXN0eWxlIGRpc3RpbmN0aW9uIGJldHdlZW4gbnVsbCBhbmQgZW1wdHkgc3RyaW5nXG4gICAgICAgICAgdXJsICs9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybCArPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1cmwgKyBoYXNoO1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4ocGF0aCwgZGF0YSkge1xuICAgICAgbGV0IGZsYXQgPSBbXTtcbiAgICAgIGxldCBrZXlzO1xuICAgICAgbGV0IGk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyAoaSA8IGRhdGEubGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgICAgaW5zZXJ0KGksIGRhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICAgIGZvciAoaSA9IDA7IChpIDwga2V5cy5sZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICBpbnNlcnQoa2V5c1tpXSwgZGF0YVtrZXlzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmbGF0O1xuICAgICAgZnVuY3Rpb24gaW5zZXJ0KGtleSwgZGF0dW0pIHtcbiAgICAgICAgaWYgKChkYXR1bSAhPSBudWxsKSAmJiAoKHR5cGVvZiBkYXR1bSkgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgIGZsYXQgPSBmbGF0LmNvbmNhdChmbGF0dGVuKHBhdGgubGVuZ3RoID8gcGF0aCArICdbJyArIGtleSArICddJyA6IGtleSwgZGF0dW0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGF0LnB1c2goWyBwYXRoLmxlbmd0aCA/IHBhdGggKyAnWycgKyBrZXkgKyAnXScgOiBrZXksIGRhdHVtIF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbiIsImltcG9ydCB1dGlsIGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQgaHR0cCBmcm9tICcuL2h0dHAuanMnO1xuXG5leHBvcnQgZGVmYXVsdCAoKSA9PiB7XG4gIHV0aWwoKTtcbiAgaHR0cCgpO1xufTtcbiIsImV4cG9ydCBkZWZhdWx0ICgpID0+IHtcbiAgYXBvcy51dGlsLndpZGdldFBsYXllcnNbJ0BhcG9zdHJvcGhlY21zL3ZpZGVvJ10gPSB7XG4gICAgc2VsZWN0b3I6ICdbZGF0YS1hcG9zLXZpZGVvLXdpZGdldF0nLFxuICAgIHBsYXllcjogZnVuY3Rpb24oZWwpIHtcbiAgICAgIGNvbnN0IHZpZGVvVXJsID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWFwb3MtdmlkZW8tdXJsJyk7XG4gICAgICBsZXQgcXVlcnlSZXN1bHQ7XG5cbiAgICAgIGlmICghdmlkZW9VcmwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBxdWVyeUFuZFBsYXkoZWwsIHtcbiAgICAgICAgdXJsOiB2aWRlb1VybFxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIHF1ZXJ5QW5kUGxheShlbCwgb3B0aW9ucykge1xuICAgICAgICBhcG9zLnV0aWwucmVtb3ZlQ2xhc3MoZWwsICdhcG9zLW9lbWJlZC1pbnZhbGlkJyk7XG4gICAgICAgIGFwb3MudXRpbC5hZGRDbGFzcyhlbCwgJ2Fwb3Mtb2VtYmVkLWJ1c3knKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnVybCkge1xuICAgICAgICAgIHJldHVybiBmYWlsKCd1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVlcnkob3B0aW9ucywgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICBxdWVyeVJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICBpZiAoZXJyIHx8IChvcHRpb25zLnR5cGUgJiYgKHJlc3VsdC50eXBlICE9PSBvcHRpb25zLnR5cGUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwoZXJyIHx8ICdpbmFwcHJvcHJpYXRlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFwb3MudXRpbC5yZW1vdmVDbGFzcyhlbCwgJ2Fwb3Mtb2VtYmVkLWJ1c3knKTtcbiAgICAgICAgICByZXR1cm4gcGxheShlbCwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHF1ZXJ5KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgIHVybDogb3B0aW9ucy51cmxcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhcG9zLmh0dHAuZ2V0KCcvYXBpL3YxL0BhcG9zdHJvcGhlY21zL29lbWJlZC9xdWVyeScsIG9wdHMsIGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGxheShlbCwgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IHNoYWtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzaGFrZXIuaW5uZXJIVE1MID0gcmVzdWx0Lmh0bWw7XG4gICAgICAgIGNvbnN0IGlubmVyID0gc2hha2VyLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlubmVyLnNldEF0dHJpYnV0ZSgnZGF0YS1hcG9zLXZpZGVvLWNhbnZhcycsICcnKTtcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGlmICghaW5uZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5uZXIucmVtb3ZlQXR0cmlidXRlKCd3aWR0aCcpO1xuICAgICAgICBpbm5lci5yZW1vdmVBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICAgICAgICBlbC5hcHBlbmQoaW5uZXIpO1xuICAgICAgICAvLyB3YWl0IGZvciBDU1Mgd2lkdGggdG8gYmUga25vd25cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBJZiBvZW1iZWQgcmVzdWx0cyBpbmNsdWRlIHdpZHRoIGFuZCBoZWlnaHQgd2UgY2FuIGdldCB0aGVcbiAgICAgICAgICAvLyB2aWRlbyBhc3BlY3QgcmF0aW8gcmlnaHRcbiAgICAgICAgICBpZiAocmVzdWx0LndpZHRoICYmIHJlc3VsdC5oZWlnaHQpIHtcbiAgICAgICAgICAgIGlubmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgcmVzaXplVmlkZW8oaW5uZXIpO1xuICAgICAgICAgICAgLy8gSWYgd2UgbmVlZCB0byBpbml0aWFsbHkgc2l6ZSB0aGUgdmlkZW8sIGFsc28gcmVzaXplIGl0IG9uIHdpbmRvd1xuICAgICAgICAgICAgLy8gcmVzaXplLlxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZUhhbmRsZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBObywgc28gYXNzdW1lIHRoZSBvZW1iZWQgSFRNTCBjb2RlIGlzIHJlc3BvbnNpdmUuXG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVzaXplVmlkZW8oY2FudmFzRWwpIHtcbiAgICAgICAgY2FudmFzRWwuc3R5bGUuaGVpZ2h0ID0gKChxdWVyeVJlc3VsdC5oZWlnaHQgLyBxdWVyeVJlc3VsdC53aWR0aCkgKiBjYW52YXNFbC5vZmZzZXRXaWR0aCkgKyAncHgnO1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gcmVzaXplSGFuZGxlcigpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICAgIHJlc2l6ZVZpZGVvKGVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWFwb3MtdmlkZW8tY2FudmFzXScpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmFpbChlcnIpIHtcbiAgICAgICAgYXBvcy51dGlsLnJlbW92ZUNsYXNzKGVsLCAnYXBvcy1vZW1iZWQtYnVzeScpO1xuICAgICAgICBhcG9zLnV0aWwuYWRkQ2xhc3MoZWwsICdhcG9zLW9lbWJlZC1pbnZhbGlkJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgaWYgKGVyciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBlbC5pbm5lckhUTUwgPSAnPHA+RXJyb3IgbG9hZGluZyB2aWRlbzwvcD4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbiIsImV4cG9ydCBkZWZhdWx0ICgpID0+IHtcbiAgLy8gWW91ciBvd24gcHJvamVjdCBsZXZlbCBKUyBtYXkgZ28gaGVyZVxuICBjb25zb2xlLmxvZygnSGVsbG8gV29ybGQnKTtcbn07XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIoZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LmFwb3MgPSB3aW5kb3cuYXBvcyB8fCB7fTtcbiAgICB2YXIgZGF0YSA9IGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5nZXRBdHRyaWJ1dGUoJ2RhdGEtYXBvcycpO1xuICAgIE9iamVjdC5hc3NpZ24od2luZG93LmFwb3MsIEpTT04ucGFyc2UoZGF0YSB8fCAne30nKSk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWFwb3MnKTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5hcG9zLm1vZHVsZXMpIHtcbiAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIE9iamVjdC52YWx1ZXMod2luZG93LmFwb3MubW9kdWxlcykpIHtcbiAgICAgICAgaWYgKG1vZHVsZS5hbGlhcykge1xuICAgICAgICAgIHdpbmRvdy5hcG9zW21vZHVsZS5hbGlhc10gPSBtb2R1bGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG59KSgpO2ltcG9ydCBpbmRleF8wQXBwIGZyb20gXCIvaG9tZS91c2VyLzEuQU5UT04vRG9jdW1lbnRzLzFXb3JrLzEuUUEvNi5Qcm9qZWN0IHdpdGggQ0lDRCBwaXBlbGluZS8zLmFwb3MtYXBwL25vZGVfbW9kdWxlcy9hcG9zdHJvcGhlL21vZHVsZXMvQGFwb3N0cm9waGVjbXMvdXRpbC91aS9zcmMvaW5kZXguanNcIjtcblxuXG5pbXBvcnQgaW5kZXhfMUFwcCBmcm9tIFwiL2hvbWUvdXNlci8xLkFOVE9OL0RvY3VtZW50cy8xV29yay8xLlFBLzYuUHJvamVjdCB3aXRoIENJQ0QgcGlwZWxpbmUvMy5hcG9zLWFwcC9ub2RlX21vZHVsZXMvYXBvc3Ryb3BoZS9tb2R1bGVzL0BhcG9zdHJvcGhlY21zL3ZpZGVvLXdpZGdldC91aS9zcmMvaW5kZXguanNcIjtcblxuXG5pbXBvcnQgaW5kZXhfMkFwcCBmcm9tIFwiL2hvbWUvdXNlci8xLkFOVE9OL0RvY3VtZW50cy8xV29yay8xLlFBLzYuUHJvamVjdCB3aXRoIENJQ0QgcGlwZWxpbmUvMy5hcG9zLWFwcC9tb2R1bGVzL2Fzc2V0L3VpL3NyYy9pbmRleC5qc1wiO1xuXG5cbiAgXG5pbXBvcnQgaW5kZXhfMFN0eWxlc2hlZXQgZnJvbSBcIi9ob21lL3VzZXIvMS5BTlRPTi9Eb2N1bWVudHMvMVdvcmsvMS5RQS82LlByb2plY3Qgd2l0aCBDSUNEIHBpcGVsaW5lLzMuYXBvcy1hcHAvbW9kdWxlcy9hc3NldC91aS9zcmMvaW5kZXguc2Nzc1wiO2luZGV4XzBBcHAoKTtcbmluZGV4XzFBcHAoKTtcbmluZGV4XzJBcHAoKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///813\n")}},__webpack_exports__={};__webpack_modules__[813]()})();
// BUILD: public

